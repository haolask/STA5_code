From 1d3e2acb32e2ab86fd72f787119f9da8206dccad Mon Sep 17 00:00:00 2001
From: Mickael Reulier <mickael.reulier@st.com>
Date: Fri, 4 Jan 2019 11:44:40 +0100
Subject: [PATCH 3/4] libweston: Allow more scanout format

We can dynamically change the primary format.
This is useful to be able to move to scanout a fullscreen surface
with a format different to the initial primary format (gbm-format).
Typical examples are to move to scanout the rear camera, video or application
when these are fullscreen and opaque.

Change-Id: I66390cb18b3726ab4d591e2d3d767c4a915b4050
Signed-off-by: Mickael Reulier <mickael.reulier@st.com>
Buglink:https://stintbugzilla.st.com/show_bug.cgi?id=118617
---
 libweston/compositor-st.c | 40 ++++++++++++++++++++++++++++++++++------
 1 file changed, 34 insertions(+), 6 deletions(-)

diff --git a/libweston/compositor-st.c b/libweston/compositor-st.c
index fdf2938..674cbd9 100644
--- a/libweston/compositor-st.c
+++ b/libweston/compositor-st.c
@@ -55,6 +55,7 @@
 #include "gl-renderer.h"
 #include "weston-egl-ext.h"
 #include "pixman-renderer.h"
+#include "pixel-formats.h"
 #include "libbacklight.h"
 #include "libinput-seat.h"
 #include "launcher-util.h"
@@ -650,28 +651,55 @@ drm_output_release_fb(struct drm_output *output, struct drm_fb *fb)
 	}
 }
 
+static bool
+format_is_supported_by_primary(uint32_t format)
+{
+	/* List of formats is dependant to display IP, this will be better managed
+	 * with unified plane with later weston version (5.0) */
+	if ((format == GBM_FORMAT_XRGB8888) || (format == GBM_FORMAT_RGBX8888) ||
+			(format == GBM_FORMAT_RGB888) || (format == GBM_FORMAT_RGB565) ||
+			(format == GBM_FORMAT_XRGB1555) || (format == GBM_FORMAT_XRGB4444) ||
+			(format == GBM_FORMAT_NV12) || (format == GBM_FORMAT_NV21) ||
+			(format == GBM_FORMAT_YUYV) || (format == GBM_FORMAT_YVYU) ||
+			(format == GBM_FORMAT_UYVY) || (format == GBM_FORMAT_VYUY))
+		return true;
+
+	return false;
+}
+
 static uint32_t
 drm_output_check_scanout_format(struct drm_output *output,
 				struct weston_surface *es, uint32_t format)
 {
 	pixman_region32_t r;
+	const struct pixel_format_info *info;
 
-	if (format == GBM_FORMAT_ARGB8888) {
-		/* We can scanout an ARGB buffer if the surface's
+	info = pixel_format_get_info(format);
+	if (!info)
+		return 0;
+
+	if (!pixel_format_is_opaque(info)) {
+		/* We can scanout an non opaque buffer if the surface's
 		 * opaque region covers the whole output, but we have
-		 * to use XRGB as the KMS format code. */
+		 * to use XRGB subtitute format as the KMS format code. */
 		pixman_region32_init_rect(&r, 0, 0,
 					  output->base.width,
 					  output->base.height);
 		pixman_region32_subtract(&r, &r, &es->opaque);
 
-		if (!pixman_region32_not_empty(&r))
-			format = GBM_FORMAT_XRGB8888;
+		if (!pixman_region32_not_empty(&r)) {
+			/* Set opaque subtitute format */
+			format = info->opaque_substitute;
+		} else {
+			/* Don't scanout a non complete opaque output region */
+			pixman_region32_fini(&r);
+			return 0;
+		}
 
 		pixman_region32_fini(&r);
 	}
 
-	if (output->gbm_format == format)
+	if (format_is_supported_by_primary(format))
 		return format;
 
 	return 0;
-- 
1.9.1


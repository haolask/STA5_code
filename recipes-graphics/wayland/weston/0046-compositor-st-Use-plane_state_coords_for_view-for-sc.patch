From 4fde30b8ed956b825894998f48db74fba2ea13bc Mon Sep 17 00:00:00 2001
From: Mickael Reulier <mickael.reulier@st.com>
Date: Mon, 4 Feb 2019 16:05:56 +0100
Subject: [PATCH 4/4] compositor-st: Use plane_state_coords_for_view for
 scanout

When using some IVI shell application (like layer-add-surfaces), scissor_enabled is set which
forbid to move to scan-out.
When looking at weston-5.0 master branch, this check has been removed and replaced
with commit "compositor-drm: Use plane_state_coords_for_view for scanout"
=> Backport master commit SHA1 7cdf231c762602b820a8ab03bae37297fb5df54f.

Change-Id: Iffa0791b4fd1bc7087f302e65557dde6a67910bf
Signed-off-by: Mickael Reulier <mickael.reulier@st.com>
Buglink:https://stintbugzilla.st.com/show_bug.cgi?id=118617
---
 libweston/compositor-st.c | 161 ++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 135 insertions(+), 26 deletions(-)

diff --git a/libweston/compositor-st.c b/libweston/compositor-st.c
index 674cbd9..c69ebc6 100644
--- a/libweston/compositor-st.c
+++ b/libweston/compositor-st.c
@@ -705,6 +705,114 @@ drm_output_check_scanout_format(struct drm_output *output,
 	return 0;
 }
 
+static bool
+drm_view_transform_supported(struct weston_view *ev, struct weston_output *output)
+{
+	struct weston_buffer_viewport *viewport = &ev->surface->buffer_viewport;
+
+	/* This will incorrectly disallow cases where the combination of
+	 * buffer and view transformations match the output transform.
+	 * Fixing this requires a full analysis of the transformation
+	 * chain. */
+	if (ev->transform.enabled &&
+	    ev->transform.matrix.type >= WESTON_MATRIX_TRANSFORM_ROTATE)
+		return false;
+
+	if (viewport->buffer.transform != output->transform)
+		return false;
+
+	return true;
+}
+
+/**
+ * Given a weston_view, fill the drm_plane_state's co-ordinates to display on
+ * a given plane.
+ */
+static bool
+drm_plane_state_coords_for_view(struct drm_sprite *state,
+				struct weston_view *ev, struct drm_output *output)
+{
+	struct weston_buffer *buffer = ev->surface->buffer_ref.buffer;
+	pixman_region32_t dest_rect, src_rect;
+	pixman_box32_t *box, tbox;
+	float sxf1, syf1, sxf2, syf2;
+
+	if (!drm_view_transform_supported(ev, &output->base))
+		return false;
+
+	/* Update the base weston_plane co-ordinates. */
+	/* TBC Comment as not used after */
+	/*box = pixman_region32_extents(&ev->transform.boundingbox);
+	state->plane->base.x = box->x1;
+	state->plane->base.y = box->y1;*/
+
+	/* First calculate the destination co-ordinates by taking the
+	 * area of the view which is visible on this output, performing any
+	 * transforms to account for output rotation and scale as necessary. */
+	pixman_region32_init(&dest_rect);
+	pixman_region32_intersect(&dest_rect, &ev->transform.boundingbox,
+				  &output->base.region);
+	pixman_region32_translate(&dest_rect, -output->base.x, -output->base.y);
+	box = pixman_region32_extents(&dest_rect);
+	tbox = weston_transformed_rect(output->base.width,
+				       output->base.height,
+				       output->base.transform,
+				       output->base.current_scale,
+				       *box);
+	state->dest_x = tbox.x1;
+	state->dest_y = tbox.y1;
+	state->dest_w = tbox.x2 - tbox.x1;
+	state->dest_h = tbox.y2 - tbox.y1;
+	pixman_region32_fini(&dest_rect);
+
+	/* Now calculate the source rectangle, by finding the extents of the
+	 * view, and working backwards to source co-ordinates. */
+	pixman_region32_init(&src_rect);
+	pixman_region32_intersect(&src_rect, &ev->transform.boundingbox,
+				  &output->base.region);
+	box = pixman_region32_extents(&src_rect);
+	weston_view_from_global_float(ev, box->x1, box->y1, &sxf1, &syf1);
+	weston_surface_to_buffer_float(ev->surface, sxf1, syf1, &sxf1, &syf1);
+	weston_view_from_global_float(ev, box->x2, box->y2, &sxf2, &syf2);
+	weston_surface_to_buffer_float(ev->surface, sxf2, syf2, &sxf2, &syf2);
+	pixman_region32_fini(&src_rect);
+
+	/* Buffer transforms may mean that x2 is to the left of x1, and/or that
+	 * y2 is above y1. */
+	if (sxf2 < sxf1) {
+		double tmp = sxf1;
+		sxf1 = sxf2;
+		sxf2 = tmp;
+	}
+	if (syf2 < syf1) {
+		double tmp = syf1;
+		syf1 = syf2;
+		syf2 = tmp;
+	}
+
+	/* Shift from S23.8 wl_fixed to U16.16 KMS fixed-point encoding. */
+	state->src_x = wl_fixed_from_double(sxf1) << 8;
+	state->src_y = wl_fixed_from_double(syf1) << 8;
+	state->src_w = wl_fixed_from_double(sxf2 - sxf1) << 8;
+	state->src_h = wl_fixed_from_double(syf2 - syf1) << 8;
+
+	/* Clamp our source co-ordinates to surface bounds; it's possible
+	 * for intermediate translations to give us slightly incorrect
+	 * co-ordinates if we have, for example, multiple zooming
+	 * transformations. View bounding boxes are also explicitly rounded
+	 * greedily. */
+	if (state->src_x < 0)
+		state->src_x = 0;
+	if (state->src_y < 0)
+		state->src_y = 0;
+	if (state->src_w > (uint32_t) ((buffer->width << 16) - state->src_x))
+		state->src_w = (buffer->width << 16) - state->src_x;
+	if (state->src_h > (uint32_t) ((buffer->height << 16) - state->src_y))
+		state->src_h = (buffer->height << 16) - state->src_y;
+
+	return true;
+}
+
 static struct weston_plane *
 drm_output_prepare_scanout_view(struct drm_output *output,
 				struct weston_view *ev)
@@ -716,6 +824,7 @@ drm_output_prepare_scanout_view(struct drm_output *output,
 	struct gbm_bo *bo;
 	uint32_t format;
 	pixman_box32_t *extents;
+	struct drm_sprite *state_tmp;
 
 	/* We use GBM to import buffers. */
 	if (b->gbm == NULL)
@@ -724,24 +833,6 @@ drm_output_prepare_scanout_view(struct drm_output *output,
 	if (buffer == NULL)
 		return NULL;
 
-	/* Make sure our view is exactly compatible with the output. */
-	if (ev->geometry.x != output->base.x ||
-	    ev->geometry.y != output->base.y)
-		return NULL;
-
-	if (ev->geometry.scissor_enabled)
-		return NULL;
-
-	if (buffer->width != output->base.current_mode->width ||
-	    buffer->height != output->base.current_mode->height)
-		return NULL;
-	if (viewport->buffer.transform != output->base.transform)
-		return NULL;
-
-	if (ev->transform.enabled &&
-	    (ev->transform.matrix.type >= WESTON_MATRIX_TRANSFORM_ROTATE))
-		return NULL;
-
 	/* Check the view spans exactly the output size, calculated in the
 	 * logical co-ordinate space. */
 	extents = pixman_region32_extents(&ev->transform.boundingbox);
@@ -755,6 +846,27 @@ drm_output_prepare_scanout_view(struct drm_output *output,
 		return NULL;
 	}
 
+	state_tmp = zalloc(sizeof(*state_tmp));
+
+	if(!drm_plane_state_coords_for_view(state_tmp, ev, output)) {
+		goto err;
+	}
+
+	if (state_tmp->dest_x != 0 || state_tmp->dest_y != 0 ||
+	    state_tmp->dest_w != (unsigned) output->base.current_mode->width ||
+	    state_tmp->dest_h != (unsigned) output->base.current_mode->height) {
+		goto err;
+	}
+
+	/* The legacy API does not let us perform cropping or scaling. */
+	if ((state_tmp->src_x != 0 || state_tmp->src_y != 0 ||
+	     state_tmp->src_w != state_tmp->dest_w << 16 ||
+	     state_tmp->src_h != state_tmp->dest_h << 16)) {
+		goto err;
+	}
+
+	free(state_tmp);
+
 	if ((dmabuf = linux_dmabuf_buffer_get(buffer->resource))) {
 		format = drm_output_check_scanout_format(output, ev->surface, dmabuf->attributes.format);
 		if (format == 0) {
@@ -790,6 +902,10 @@ drm_output_prepare_scanout_view(struct drm_output *output,
 	drm_fb_set_buffer(output->next, buffer);
 
 	return &output->fb_plane;
+
+err:
+		free(state_tmp);
+		return NULL;
 }
 
 static void
@@ -1242,13 +1358,6 @@ drm_output_check_sprite_format(struct drm_sprite *s,
 	return 0;
 }
 
-static int
-drm_view_transform_supported(struct weston_view *ev)
-{
-	return !ev->transform.enabled ||
-		(ev->transform.matrix.type < WESTON_MATRIX_TRANSFORM_ROTATE);
-}
-
 static struct weston_plane *
 drm_output_prepare_overlay_view(struct drm_output *output,
 				struct weston_view *ev, int zorder)
@@ -1314,7 +1423,7 @@ drm_output_prepare_overlay_view(struct drm_output *output,
 		goto no_overlay;
 	}
 
-	if (!drm_view_transform_supported(ev)) {
+	if (!drm_view_transform_supported(ev, &output->base)) {
 		weston_xlog("    overlay check: transform not supported\n");
 		goto no_overlay;
 	}
-- 
1.9.1


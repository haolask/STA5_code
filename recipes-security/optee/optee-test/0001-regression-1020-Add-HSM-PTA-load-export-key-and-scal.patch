From 1784e10be34cf323a719607ca1fee2c2a5ca7d68 Mon Sep 17 00:00:00 2001
From: Olivier Claude LEBRETON <olivier.lebreton@st.com>
Date: Fri, 16 Nov 2018 08:53:25 +0100
Subject: [PATCH 1/3] regression: 1020: Add HSM PTA load/export key and scalar
 multiplication tests

Add 2 tests cases:
- ECDSA signing with an ECC key pair exported and loaded in protected form
  without public key coordinates
  - Test Specific key handling in case of ECC key pair without public key X & Y
    coordinates.
  => Test enable by default

- ECC Scalar Multiplication and Addition
  - Export of ECC key pair in protected form
  - Load of ECC key pair in protected form
  - ECDSA signature generation using the temporary enrollment key previously
    loaded
  => test disable by default

Signed-off-by: Olivier Claude LEBRETON <olivier.lebreton@st.com>
---
 host/xtest/regression_1000.c | 647 ++++++++++++++++++++++++++++++++++++-------
 host/xtest/regression_4000.c | 183 ++++++++++--
 2 files changed, 717 insertions(+), 113 deletions(-)

diff --git a/host/xtest/regression_1000.c b/host/xtest/regression_1000.c
index 251bdce..5281c05 100644
--- a/host/xtest/regression_1000.c
+++ b/host/xtest/regression_1000.c
@@ -1282,15 +1282,15 @@ static void xtest_tee_test_1016(ADBG_Case_t *c)
 struct xtest_hsm_case
 {
 	unsigned int level;
-    const uint8_t *secret;            /* Secret byte array */
-    uint32_t secret_sz;
-    const uint8_t *label;             /* Label byte array */
-    uint32_t label_sz;
-    const uint8_t *seed;              /* Seed byte array */
-    uint32_t seed_sz;
-    const uint8_t *prfout;			  /* Expected PRF output byte array */
-    uint32_t prfout_sz;
-    const uint32_t sha_id;            /* SHA algorithm Identifier */
+	const uint8_t *secret;  /* Secret byte array */
+	uint32_t secret_sz;
+	const uint8_t *label;   /* Label byte array */
+	uint32_t label_sz;
+	const uint8_t *seed;    /* Seed byte array */
+	uint32_t seed_sz;
+	const uint8_t *prfout;	/* Expected PRF output byte array */
+	uint32_t prfout_sz;
+	const uint32_t sha_id;  /* SHA algorithm Identifier */
 };
 
 #define XTEST_HSM_CASE(lvl, sc, sc_sz, lb, lb_sz, sd, sd_sz, out, out_sz, sha) \
@@ -1299,105 +1299,152 @@ struct xtest_hsm_case
 
 static const struct xtest_hsm_case hsm_cases[] = {
 	XTEST_HSM_CASE(0, secret0, SECRET0_SIZE, label0, LABEL0_SIZE,
-				   seed0, SEED0_SIZE, prfout0, PRFOUT0_SIZE, SHA_ID0),
+		       seed0, SEED0_SIZE, prfout0, PRFOUT0_SIZE, SHA_ID0),
 	XTEST_HSM_CASE(0, secret1, SECRET1_SIZE, label1, LABEL1_SIZE,
-				   seed1, SEED1_SIZE, prfout1, PRFOUT1_SIZE, SHA_ID1),
+		       seed1, SEED1_SIZE, prfout1, PRFOUT1_SIZE, SHA_ID1),
 	XTEST_HSM_CASE(0, secret2, SECRET2_SIZE, label2, LABEL2_SIZE,
-				   seed2, SEED2_SIZE, prfout2, PRFOUT2_SIZE, SHA_ID2),
+		       seed2, SEED2_SIZE, prfout2, PRFOUT2_SIZE, SHA_ID2),
 	XTEST_HSM_CASE(0, secret3, SECRET3_SIZE, label3, LABEL3_SIZE,
-				   seed3, SEED3_SIZE, prfout3, PRFOUT3_SIZE, SHA_ID3),
+		       seed3, SEED3_SIZE, prfout3, PRFOUT3_SIZE, SHA_ID3),
 	XTEST_HSM_CASE(0, secret4, SECRET4_SIZE, label4, LABEL4_SIZE,
-				   seed4, SEED4_SIZE, prfout4, PRFOUT4_SIZE, SHA_ID4),
+		       seed4, SEED4_SIZE, prfout4, PRFOUT4_SIZE, SHA_ID4),
 	XTEST_HSM_CASE(1, secret5, SECRET5_SIZE, label5, LABEL5_SIZE,
-				   seed5, SEED5_SIZE, prfout5, PRFOUT5_SIZE, SHA_ID5),
+		       seed5, SEED5_SIZE, prfout5, PRFOUT5_SIZE, SHA_ID5),
 	XTEST_HSM_CASE(1, secret6, SECRET6_SIZE, label6, LABEL6_SIZE,
-				   seed6, SEED6_SIZE, prfout6, PRFOUT6_SIZE, SHA_ID6),
+		       seed6, SEED6_SIZE, prfout6, PRFOUT6_SIZE, SHA_ID6),
 	XTEST_HSM_CASE(1, secret7, SECRET7_SIZE, label7, LABEL7_SIZE,
-				   seed7, SEED7_SIZE, prfout7, PRFOUT7_SIZE, SHA_ID7),
+		       seed7, SEED7_SIZE, prfout7, PRFOUT7_SIZE, SHA_ID7),
 	XTEST_HSM_CASE(1, secret8, SECRET8_SIZE, label8, LABEL8_SIZE,
-				   seed8, SEED8_SIZE, prfout8, PRFOUT8_SIZE, SHA_ID8),
+		       seed8, SEED8_SIZE, prfout8, PRFOUT8_SIZE, SHA_ID8),
 	XTEST_HSM_CASE(1, secret9, SECRET9_SIZE, label9, LABEL9_SIZE,
-				   seed9, SEED9_SIZE, prfout9, PRFOUT9_SIZE, SHA_ID9),
+		       seed9, SEED9_SIZE, prfout9, PRFOUT9_SIZE, SHA_ID9),
 	XTEST_HSM_CASE(2, secret10, SECRET10_SIZE, label10, LABEL10_SIZE,
-				   seed10, SEED10_SIZE, prfout10, PRFOUT10_SIZE, SHA_ID10),
+		       seed10, SEED10_SIZE, prfout10, PRFOUT10_SIZE, SHA_ID10),
 	XTEST_HSM_CASE(2, secret11, SECRET11_SIZE, label11, LABEL11_SIZE,
-				   seed11, SEED11_SIZE, prfout11, PRFOUT11_SIZE, SHA_ID11),
+		       seed11, SEED11_SIZE, prfout11, PRFOUT11_SIZE, SHA_ID11),
 	XTEST_HSM_CASE(2, secret12, SECRET12_SIZE, label12, LABEL12_SIZE,
-				   seed12, SEED12_SIZE, prfout12, PRFOUT12_SIZE, SHA_ID12),
+		       seed12, SEED12_SIZE, prfout12, PRFOUT12_SIZE, SHA_ID12),
 	XTEST_HSM_CASE(2, secret13, SECRET13_SIZE, label13, LABEL13_SIZE,
-				   seed13, SEED13_SIZE, prfout13, PRFOUT13_SIZE, SHA_ID13),
+		       seed13, SEED13_SIZE, prfout13, PRFOUT13_SIZE, SHA_ID13),
 	XTEST_HSM_CASE(2, secret14, SECRET14_SIZE, label14, LABEL14_SIZE,
-				   seed14, SEED14_SIZE, prfout14, PRFOUT14_SIZE, SHA_ID14),
+		       seed14, SEED14_SIZE, prfout14, PRFOUT14_SIZE, SHA_ID14),
 	XTEST_HSM_CASE(5, secret15, SECRET15_SIZE, label15, LABEL15_SIZE,
-				   seed15, SEED15_SIZE, prfout15, PRFOUT15_SIZE, SHA_ID15),
+		       seed15, SEED15_SIZE, prfout15, PRFOUT15_SIZE, SHA_ID15),
 	XTEST_HSM_CASE(5, secret16, SECRET16_SIZE, label16, LABEL16_SIZE,
-				   seed16, SEED16_SIZE, prfout16, PRFOUT16_SIZE, SHA_ID16),
+		       seed16, SEED16_SIZE, prfout16, PRFOUT16_SIZE, SHA_ID16),
 	XTEST_HSM_CASE(5, secret17, SECRET17_SIZE, label17, LABEL17_SIZE,
-				   seed17, SEED17_SIZE, prfout17, PRFOUT17_SIZE, SHA_ID17),
+		       seed17, SEED17_SIZE, prfout17, PRFOUT17_SIZE, SHA_ID17),
 	XTEST_HSM_CASE(5, secret18, SECRET18_SIZE, label18, LABEL18_SIZE,
-				   seed18, SEED18_SIZE, prfout18, PRFOUT18_SIZE, SHA_ID18),
+		       seed18, SEED18_SIZE, prfout18, PRFOUT18_SIZE, SHA_ID18),
 	XTEST_HSM_CASE(5, secret19, SECRET19_SIZE, label19, LABEL19_SIZE,
-				   seed19, SEED19_SIZE, prfout19, PRFOUT19_SIZE, SHA_ID19),
+		       seed19, SEED19_SIZE, prfout19, PRFOUT19_SIZE, SHA_ID19),
 	XTEST_HSM_CASE(10, secret20, SECRET20_SIZE, label20, LABEL20_SIZE,
-				   seed20, SEED20_SIZE, prfout20, PRFOUT20_SIZE, SHA_ID20),
+		       seed20, SEED20_SIZE, prfout20, PRFOUT20_SIZE, SHA_ID20),
 	XTEST_HSM_CASE(10, secret21, SECRET21_SIZE, label21, LABEL21_SIZE,
-				   seed21, SEED21_SIZE, prfout21, PRFOUT21_SIZE, SHA_ID21),
+		       seed21, SEED21_SIZE, prfout21, PRFOUT21_SIZE, SHA_ID21),
 	XTEST_HSM_CASE(10, secret22, SECRET22_SIZE, label22, LABEL22_SIZE,
-				   seed22, SEED22_SIZE, prfout22, PRFOUT22_SIZE, SHA_ID22),
+		       seed22, SEED22_SIZE, prfout22, PRFOUT22_SIZE, SHA_ID22),
 	XTEST_HSM_CASE(10, secret23, SECRET23_SIZE, label23, LABEL23_SIZE,
-				   seed23, SEED23_SIZE, prfout23, PRFOUT23_SIZE, SHA_ID23),
+		       seed23, SEED23_SIZE, prfout23, PRFOUT23_SIZE, SHA_ID23),
 	XTEST_HSM_CASE(10, secret24, SECRET24_SIZE, label24, LABEL24_SIZE,
-				   seed24, SEED24_SIZE, prfout24, PRFOUT24_SIZE, SHA_ID24),
+		       seed24, SEED24_SIZE, prfout24, PRFOUT24_SIZE, SHA_ID24),
 	XTEST_HSM_CASE(15, secret25, SECRET25_SIZE, label25, LABEL25_SIZE,
-				   seed25, SEED25_SIZE, prfout25, PRFOUT25_SIZE, SHA_ID25),
+		       seed25, SEED25_SIZE, prfout25, PRFOUT25_SIZE, SHA_ID25),
 	XTEST_HSM_CASE(15, secret26, SECRET26_SIZE, label26, LABEL26_SIZE,
-				   seed26, SEED26_SIZE, prfout26, PRFOUT26_SIZE, SHA_ID26),
+		       seed26, SEED26_SIZE, prfout26, PRFOUT26_SIZE, SHA_ID26),
 	XTEST_HSM_CASE(15, secret27, SECRET27_SIZE, label27, LABEL27_SIZE,
-				   seed27, SEED27_SIZE, prfout27, PRFOUT27_SIZE, SHA_ID27),
+		       seed27, SEED27_SIZE, prfout27, PRFOUT27_SIZE, SHA_ID27),
 	XTEST_HSM_CASE(15, secret28, SECRET28_SIZE, label28, LABEL28_SIZE,
-				   seed28, SEED28_SIZE, prfout28, PRFOUT28_SIZE, SHA_ID28),
+		       seed28, SEED28_SIZE, prfout28, PRFOUT28_SIZE, SHA_ID28),
 	XTEST_HSM_CASE(15, secret29, SECRET29_SIZE, label29, LABEL29_SIZE,
-				   seed29, SEED29_SIZE, prfout29, PRFOUT29_SIZE, SHA_ID29)
+		       seed29, SEED29_SIZE, prfout29, PRFOUT29_SIZE, SHA_ID29)
 };
 
+//#define HSM_TEST_DEBUG
+//#define HSM_SCALAR_TEST
+
+/*
+ * ECC keypair P384 descriptors
+ */
 static const uint8_t nist_private[] = {
 /* d */
  0xad, 0xca, 0x36, 0x4e, 0xf1, 0x44, 0xa2, 0x1d, 0xf6, 0x4b, 0x16, 0x36,
  0x15, 0xe8, 0x34, 0x9c, 0xf7, 0x4e, 0xe9, 0xdb, 0xf7, 0x28, 0x10, 0x42,
  0x15, 0xc5, 0x32, 0x07, 0x3a, 0x7f, 0x74, 0xe2, 0xf6, 0x73, 0x85, 0x77,
- 0x9f, 0x7f, 0x74, 0xab, 0x34, 0x4c, 0xc3, 0xc7, 0xda, 0x06, 0x1c, 0xf6,
-
+ 0x9f, 0x7f, 0x74, 0xab, 0x34, 0x4c, 0xc3, 0xc7, 0xda, 0x06, 0x1c, 0xf6
 };
 static const uint8_t nist_public_x[] = {
 /* Qx */
  0xef, 0x94, 0x8d, 0xaa, 0xe6, 0x82, 0x42, 0x33, 0x0a, 0x73, 0x58, 0xef,
  0x73, 0xf2, 0x3b, 0x56, 0xc0, 0x7e, 0x37, 0x12, 0x62, 0x66, 0xdb, 0x3f,
  0xa6, 0xee, 0xa2, 0x33, 0xa0, 0x4a, 0x9b, 0x3e, 0x49, 0x15, 0x23, 0x3d,
- 0xd6, 0x75, 0x44, 0x27, 0xcd, 0x4b, 0x71, 0xb7, 0x58, 0x54, 0x07, 0x7d,
-
+ 0xd6, 0x75, 0x44, 0x27, 0xcd, 0x4b, 0x71, 0xb7, 0x58, 0x54, 0x07, 0x7d
 };
 static const uint8_t nist_public_y[] = {
 /* Qy */
  0x00, 0x94, 0x53, 0xef, 0x18, 0x28, 0xea, 0xff, 0x9e, 0x17, 0xc8, 0x56,
  0xd4, 0xfc, 0x18, 0x95, 0xab, 0x60, 0x05, 0x13, 0x12, 0xc3, 0xe1, 0xdb,
  0x1e, 0x37, 0x66, 0x56, 0x64, 0x38, 0xb2, 0x99, 0x0c, 0xbf, 0x99, 0x45,
- 0xc2, 0x54, 0x56, 0x19, 0xe3, 0xe0, 0x14, 0x5b, 0xc6, 0xa7, 0x90, 0x04,
+ 0xc2, 0x54, 0x56, 0x19, 0xe3, 0xe0, 0x14, 0x5b, 0xc6, 0xa7, 0x90, 0x04
+};
 
+/*
+ * ECC private key P256 and scalar descriptors
+ */
+static const uint8_t priv_key_d_p256[] = {
+ 0x51, 0x9b, 0x42, 0x3d, 0x71, 0x5f, 0x8b, 0x58, 0x1f, 0x4f, 0xa8, 0xee,
+ 0x59, 0xf4, 0x77, 0x1a, 0x5b, 0x44, 0xc8, 0x13, 0x0b, 0x4e, 0x3e, 0xac,
+ 0xca, 0x54, 0xa5, 0x6d, 0xda, 0x72, 0xb4, 0x64
+};
+static const uint8_t pub_key_empty_p256[] = {
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+#ifdef HSM_SCALAR_TEST
+static const uint8_t pub_key_x_p256[] = {
+ 0x1c, 0xcb, 0xe9, 0x1c, 0x07, 0x5f, 0xc7, 0xf4, 0xf0, 0x33, 0xbf, 0xa2,
+ 0x48, 0xdb, 0x8f, 0xcc, 0xd3, 0x56, 0x5d, 0xe9, 0x4b, 0xbf, 0xb1, 0x2f,
+ 0x3c, 0x59, 0xff, 0x46, 0xc2, 0x71, 0xbf, 0x83
+};
+static const uint8_t pub_key_y_p256[] = {
+ 0xce, 0x40, 0x14, 0xc6, 0x88, 0x11, 0xf9, 0xa2, 0x1a, 0x1f, 0xdb, 0x2c,
+ 0x0e, 0x61, 0x13, 0xe0, 0x6d, 0xb7, 0xca, 0x93, 0xb7, 0x40, 0x4e, 0x78,
+ 0xdc, 0x7c, 0xcd, 0x5c, 0xa8, 0x9a, 0x4c, 0xa9
 };
+static const uint8_t scalar_multiplier_p256[] = {
+ 0x94, 0xa1, 0xbb, 0xb1, 0x4b, 0x90, 0x6a, 0x61, 0xa2, 0x80, 0xf2, 0x45,
+ 0xf9, 0xe9, 0x3c, 0x7f, 0x3b, 0x4a, 0x62, 0x47, 0x82, 0x4f, 0x5d, 0x33,
+ 0xb9, 0x67, 0x07, 0x87, 0x64, 0x2a, 0x68, 0xde
+};
+static const uint8_t scalar_addend_p256[] = {
+ 0x6d, 0x3e, 0x71, 0x88, 0x2c, 0x3b, 0x83, 0xb1, 0x56, 0xbb, 0x14, 0xe0,
+ 0xab, 0x18, 0x4a, 0xa9, 0xfb, 0x72, 0x80, 0x68, 0xd3, 0xae, 0x9f, 0xac,
+ 0x42, 0x11, 0x87, 0xae, 0x0b, 0x2f, 0x34, 0xc6
+};
+#endif /* HSM_SCALAR_TEST */
 
 #define MAX_BUF_LEN		256
 #define MAX_KEY_LEN		68
-#define ECC_KEY_INDEX	0
-#define KS_MBX_BUFFER	0x7005FF80
+#define ECC_KEY_INDEX		0
+#define KS_MBX_BUFFER		0x7005FF80
+
+#define ECC_KEY_P256_SIZE	32
+#define ECC_KEY_M1_SIZE		32
+#define ECC_KEY_M2_SIZE		224  /* To support P521 */
+#define ECC_KEY_M3_SIZE		16
+#define ECC_KEY_M4_SIZE		32
+#define ECC_KEY_M5_SIZE		16
+
+
+TEEC_Result xtest_tee_ecdsa_test(ADBG_Case_t *c, uint32_t curve, void *key_x,
+				 void *key_y);
 
 static void xtest_tee_test_1020(ADBG_Case_t *c)
 {
 	TEEC_Session session = { 0 };
 	uint32_t ret_orig;
 	size_t n;
-	uint8_t prfres[MAX_BUF_LEN] = { 0 };
-	uint8_t pubkey_x[MAX_KEY_LEN] = { 0 };
-	uint8_t pubkey_y[MAX_KEY_LEN] = { 0 };
 
 	if (!ADBG_EXPECT_TEEC_SUCCESS(c,
 		xtest_teec_open_session(&session, &hsm_pta_uuid, NULL,
@@ -1412,12 +1459,13 @@ static void xtest_tee_test_1020(ADBG_Case_t *c)
 		TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
 
 		op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_OUTPUT, TEEC_NONE,
-							TEEC_NONE, TEEC_NONE);
+						 TEEC_NONE, TEEC_NONE);
 		op.params[0].value.a = 0;
 		op.params[0].value.b = 0;
 
-		if (!ADBG_EXPECT_TEEC_SUCCESS(c, TEEC_InvokeCommand(
-						&session, PTA_HSM_CMD_GET_FW_ID, &op, &ret_orig)))
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session, PTA_HSM_CMD_GET_FW_ID,
+					   &op, &ret_orig)))
 			goto out;
 
 		Do_ADBG_Log("    HSM FW version ID: %x", op.params[0].value.a);
@@ -1431,9 +1479,10 @@ static void xtest_tee_test_1020(ADBG_Case_t *c)
 	{
 		TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
 		op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,
-							TEEC_MEMREF_TEMP_INPUT,
-							TEEC_MEMREF_TEMP_INPUT,
-							TEEC_MEMREF_TEMP_INOUT);
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INOUT);
+		uint8_t prfres[MAX_BUF_LEN] = { 0 };
 
 		for (n = 0; n < ARRAY_SIZE(hsm_cases); n++) {
 			const struct xtest_hsm_case *tv = hsm_cases + n;
@@ -1442,7 +1491,7 @@ static void xtest_tee_test_1020(ADBG_Case_t *c)
 				continue;
 
 			Do_ADBG_Log("    Generating %d bytes with sha_id %d",
-						tv->prfout_sz, tv->sha_id);
+				    tv->prfout_sz, tv->sha_id);
 
 			/* Initialize Inputs with values from test vectors */
 			op.params[0].tmpref.buffer = (void *)tv->secret;
@@ -1458,19 +1507,22 @@ static void xtest_tee_test_1020(ADBG_Case_t *c)
 			op.params[3].tmpref.buffer = (void *)prfres;
 			op.params[3].tmpref.size = tv->prfout_sz;
 			/*
-			 * Set 1st word of output buffer to size reserved to buffer receiving
-			 * the derived secret.
+			 * Set 1st word of output buffer to size reserved to
+			 * buffer receiving the derived secret.
 			 * Set 2nd word of buffer to hash algorithm identifier.
 			 */
 			*((uint32_t *)op.params[3].tmpref.buffer) = MAX_BUF_LEN;
-			*((uint32_t *)op.params[3].tmpref.buffer + 1) = tv->sha_id;
+			*((uint32_t *)op.params[3].tmpref.buffer + 1) =
+								tv->sha_id;
 
-			if (!ADBG_EXPECT_TEEC_SUCCESS(c, TEEC_InvokeCommand(
-							&session, PTA_HSM_CMD_TLSV12_PRF, &op, &ret_orig)))
+			if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+				TEEC_InvokeCommand(&session,
+						   PTA_HSM_CMD_TLSV12_PRF,
+						   &op, &ret_orig)))
 				goto out;
 
-			(void)ADBG_EXPECT_BUFFER(c, tv->prfout, tv->prfout_sz, prfres,
-									 tv->prfout_sz);
+			(void)ADBG_EXPECT_BUFFER(c, tv->prfout, tv->prfout_sz,
+						 prfres, tv->prfout_sz);
 		}
 	}
 	Do_ADBG_EndSubCase(c, NULL);
@@ -1478,29 +1530,53 @@ static void xtest_tee_test_1020(ADBG_Case_t *c)
 	/*
 	 * PTA Cmd: Regenerate a new ECC key pair
 	 */
+/* Require support of Key Storage in A7 */
+#if 0
+#define ECC_KEY_FLAG_VERIF	BIT(0)
+#define ECC_KEY_FLAG_SIGN	BIT(1)
 	/* TODO */
+	Do_ADBG_BeginSubCase(c, "Regenerate a new ECC key pair wo restriction");
+	{
+		TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
+
+		op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INPUT,
+						 TEEC_VALUE_INPUT,
+						 TEEC_VALUE_INPUT,
+						 TEEC_NONE);
+
+		/* Initialize Inputs parameters */
+		op.params[0].value.a = ECC_KEY_INDEX;
+		op.params[1].value.a = ECC_KEY_FLAG_VERIF | ECC_KEY_FLAG_SIGN;
+		op.params[2].value.a = TEE_ECC_CURVE_NIST_P256;
+
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session, PTA_HSM_CMD_ECC_KEY_REGEN_SEC_LESS,
+					   &op, &ret_orig)))
+			goto out;
+	}
+	Do_ADBG_EndSubCase(c, NULL);
 
 	/*
 	 * PTA Cmd: Key storage initialization
 	 */
-#if 0	/* Require Key Storage in A7 is supported */
 	Do_ADBG_BeginSubCase(c, "Key storage initialization");
 	{
 		TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
 
 		op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INPUT, TEEC_NONE,
-							TEEC_NONE, TEEC_NONE);
+						 TEEC_NONE, TEEC_NONE);
 
 		/* Initialize Inputs parameters */
 		op.params[0].value.a = KS_MBX_BUFFER;
 		op.params[0].value.b = 0;
 
-		if (!ADBG_EXPECT_TEEC_SUCCESS(c, TEEC_InvokeCommand(
-						&session, PTA_HSM_CMD_KS_INIT, &op, &ret_orig)))
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session, PTA_HSM_CMD_KS_INIT,
+					   &op, &ret_orig)))
 			goto out;
 	}
 	Do_ADBG_EndSubCase(c, NULL);
-#endif
+#endif /* 0 */
 
 	/*
 	 * PTA Cmd: Export of ECC Public key
@@ -1511,14 +1587,16 @@ static void xtest_tee_test_1020(ADBG_Case_t *c)
 	Do_ADBG_BeginSubCase(c, "Export of ECC Public key");
 	{
 		TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
+		uint8_t pubkey_x[MAX_KEY_LEN] = { 0 };
+		uint8_t pubkey_y[MAX_KEY_LEN] = { 0 };
 
 		/*
 		 * Load ECC RAM key
 		 */
 		op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,
-							TEEC_MEMREF_TEMP_INPUT,
-							TEEC_MEMREF_TEMP_INPUT,
-							TEEC_VALUE_INPUT);
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_VALUE_INPUT);
 
 		/* Initialize Inputs parameters */
 		op.params[0].tmpref.buffer = (void *)nist_public_x;
@@ -1529,55 +1607,436 @@ static void xtest_tee_test_1020(ADBG_Case_t *c)
 		op.params[2].tmpref.size = sizeof(nist_private);
 		op.params[3].value.a = TEE_ECC_CURVE_NIST_P384;
 
-		if (!ADBG_EXPECT_TEEC_SUCCESS(c, TEEC_InvokeCommand(
-						&session, PTA_HSM_CMD_LOAD_ECC_RAM_KEY, &op, &ret_orig)))
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session,
+					   PTA_HSM_CMD_LOAD_ECC_RAM_KEY,
+					   &op, &ret_orig)))
 			goto out;
 
 		/*
 		 * Export ECC public key previouly loaded
 		 */
 		memset((void *)&op, 0, sizeof(TEEC_Operation));
-		op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INPUT, TEEC_VALUE_OUTPUT,
-							TEEC_MEMREF_TEMP_OUTPUT, TEEC_MEMREF_TEMP_OUTPUT);
+		op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INPUT,
+						 TEEC_MEMREF_TEMP_OUTPUT,
+						 TEEC_MEMREF_TEMP_OUTPUT,
+						 TEEC_NONE);
 
 		/* Set Inputs parameters */
 		op.params[0].value.a = ECC_KEY_INDEX;
 
 		/* Set Output parameters */
-		/* op.params[1].value.a & b already initialize */
-
 		memset(pubkey_x, 0, sizeof(pubkey_x));
-		op.params[2].tmpref.buffer = (void *)pubkey_x;
-		op.params[2].tmpref.size = MAX_KEY_LEN;
+		op.params[1].tmpref.buffer = (void *)pubkey_x;
+		op.params[1].tmpref.size = MAX_KEY_LEN;
 
 		memset(pubkey_y, 0, sizeof(pubkey_y));
-		op.params[3].tmpref.buffer = (void *)pubkey_y;
-		op.params[3].tmpref.size = MAX_KEY_LEN;
+		op.params[2].tmpref.buffer = (void *)pubkey_y;
+		op.params[2].tmpref.size = MAX_KEY_LEN;
 
-		if (!ADBG_EXPECT_TEEC_SUCCESS(c, TEEC_InvokeCommand(
-						&session, PTA_HSM_CMD_PUB_KEY_EXP, &op, &ret_orig)))
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session, PTA_HSM_CMD_PUB_KEY_EXP,
+					   &op, &ret_orig)))
 			goto out;
 
 		/* Check if expected key pair */
-		if (!ADBG_EXPECT(c, TEE_ECC_CURVE_NIST_P384, op.params[1].value.a))
+		if (!ADBG_EXPECT_BUFFER(c, nist_public_x, sizeof(nist_public_x),
+					pubkey_x, op.params[1].tmpref.size))
 			goto out;
-		if (!ADBG_EXPECT_BUFFER(c, nist_public_x,
-			sizeof(nist_public_x), pubkey_x, op.params[2].tmpref.size))
+		if (!ADBG_EXPECT_BUFFER(c, nist_public_y, sizeof(nist_public_y),
+					pubkey_y, op.params[2].tmpref.size))
 			goto out;
-		if (!ADBG_EXPECT_BUFFER(c, nist_public_y,
-			sizeof(nist_public_y), pubkey_y, op.params[3].tmpref.size))
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- Public key X coordinate:");
+		Do_ADBG_HexLog(pubkey_x, op.params[1].tmpref.size, 16);
+		Do_ADBG_Log("- Public key Y coordinate:");
+		Do_ADBG_HexLog(pubkey_y, op.params[2].tmpref.size, 16);
+#endif
+	}
+	Do_ADBG_EndSubCase(c, NULL);
+
+	/*
+	 * PTA Cmd: ECDSA signing with an ECC key pair exported and loaded in
+	 *          protected form without public key coordinates
+	 *
+	 * For test purpose, execute the following sequence:
+	 * -> Load ECC RAM key with private key only
+	 *
+	 * -> Export of ECC key pair in protected form
+	 *    - export the loaded key pair and store it in host memory area in
+	 *      protected form.
+	 *
+	 * -> Load of ECC key pair in protected form
+	 *    - load into eHSM the ECC key pair previously stored by host
+	 *      application in protected form.
+	 *
+	 * -> ECDSA signature generation with exported key
+	 *    - Open 2nd session to call ECDSA cryptographic service
+	 *    - ECC key to be used for the ECDSA signature generation has been
+	 *      loaded just before and use public key x & y exported in the
+	 *      crypto ECDSA request.
+	 */
+	Do_ADBG_BeginSubCase(c,
+		"ECDSA signing with an ECC keypair without public coordinates");
+	{
+		TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
+		uint8_t m1[ECC_KEY_M1_SIZE] = { 0 };
+		uint8_t m2[ECC_KEY_M2_SIZE] = { 0 };
+		uint8_t m3[ECC_KEY_M3_SIZE] = { 0 };
+		uint8_t m45[ECC_KEY_M4_SIZE + ECC_KEY_M5_SIZE] = { 0 };
+		uint8_t pubkey[2 * ECC_KEY_P256_SIZE] = { 0 };
+		uint8_t *pubkey_x = NULL;
+		uint8_t *pubkey_y = NULL;
+
+		/*
+		 * Load ECC RAM key
+		 */
+		op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_VALUE_INPUT);
+
+		/* Initialize Inputs parameters */
+		op.params[0].tmpref.buffer = (void *)pub_key_empty_p256;
+		op.params[0].tmpref.size = sizeof(pub_key_empty_p256);
+		op.params[1].tmpref.buffer = (void *)pub_key_empty_p256;
+		op.params[1].tmpref.size = sizeof(pub_key_empty_p256);
+		op.params[2].tmpref.buffer = (void *)priv_key_d_p256;
+		op.params[2].tmpref.size = sizeof(priv_key_d_p256);
+		op.params[3].value.a = TEE_ECC_CURVE_NIST_P256;
+
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session,
+					   PTA_HSM_CMD_LOAD_ECC_RAM_KEY,
+					   &op, &ret_orig)))
+			goto out;
+
+		/*
+		 * Export of ECC key pair previously calculated in protected form
+		 */
+		memset((void *)&op, 0, sizeof(TEEC_Operation));
+		op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INOUT,
+						 TEEC_MEMREF_TEMP_INOUT,
+						 TEEC_MEMREF_TEMP_OUTPUT,
+						 TEEC_MEMREF_TEMP_OUTPUT);
+
+		/* Initialize Inputs parameters */
+		/* 1st location of the m1 buffer is set to index of the key to
+		 * export */
+		op.params[0].tmpref.buffer = (void *)m1;
+		op.params[0].tmpref.size = ECC_KEY_M1_SIZE;
+		*((uint32_t *)op.params[0].tmpref.buffer) = ECC_KEY_INDEX;
+
+		/* 1st location of the m2 buffer is set to size of the memory
+		 * allocated for the M2 message */
+		op.params[1].tmpref.buffer = (void *)m2;
+		op.params[1].tmpref.size = ECC_KEY_M2_SIZE;
+		*((uint32_t *)op.params[1].tmpref.buffer) = ECC_KEY_M2_SIZE;
+
+		/* Initialize Outputs parameters */
+		op.params[2].tmpref.buffer = (void *)m3;
+		op.params[2].tmpref.size = ECC_KEY_M3_SIZE;
+		op.params[3].tmpref.buffer = (void *)m45;
+		op.params[3].tmpref.size = ECC_KEY_M4_SIZE + ECC_KEY_M5_SIZE;
+
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session,
+					   PTA_HSM_CMD_EXP_ECC_KEY_PROT,
+					   &op, &ret_orig)))
 			goto out;
 
-		//Do_ADBG_Log("Elliptic curve identifier: %x", op.params[1].value.a);
-		//Do_ADBG_Log("Public key X coordinate:");
-		//Do_ADBG_HexLog(pubkey_x, op.params[2].tmpref.size, 16);
-		//Do_ADBG_Log("Public key Y coordinate:");
-		//Do_ADBG_HexLog(pubkey_y, op.params[3].tmpref.size, 16);
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- Export of ECC key pair in protected form");
+		Do_ADBG_Log("  - M1:");
+		Do_ADBG_HexLog(op.params[0].tmpref.buffer,
+			       op.params[0].tmpref.size, 16);
+		Do_ADBG_Log("  - M2:");
+		Do_ADBG_HexLog(op.params[1].tmpref.buffer,
+			       op.params[1].tmpref.size, 16);
+		Do_ADBG_Log("  - M3:");
+		Do_ADBG_HexLog(op.params[2].tmpref.buffer,
+			       op.params[2].tmpref.size, 16);
+		Do_ADBG_Log("  - M45:");
+		Do_ADBG_HexLog(op.params[3].tmpref.buffer,
+			       op.params[3].tmpref.size, 16);
+#endif
+
+		/*
+		 * Load of ECC key pair previously stored in protected form
+		 */
+		memset((void *)&op, 0, sizeof(TEEC_Operation));
+		op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INOUT);
+
+		/* Initialize Inputs parameters */
+		op.params[0].tmpref.buffer = (void *)m1;
+		op.params[0].tmpref.size = ECC_KEY_M1_SIZE;
+		op.params[1].tmpref.buffer = (void *)m2;
+		op.params[1].tmpref.size = ECC_KEY_M2_SIZE;
+		op.params[2].tmpref.buffer = (void *)m3;
+		op.params[2].tmpref.size = ECC_KEY_M3_SIZE;
+
+		/* Initialize Outputs parameters */
+		/* Output buffer is allocated to return the public key x and y
+		 * related to the loaded key pair.
+		 * In input, this output buffer is filled with the M4 and M5
+		 * messages which will be used for the loading attestation
+		 * checking */
+		memcpy(pubkey, m45, ECC_KEY_M4_SIZE + ECC_KEY_M5_SIZE);
+		op.params[3].tmpref.buffer = (void *)pubkey;
+		op.params[3].tmpref.size = 2 * ECC_KEY_P256_SIZE;
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- Load of exported ECC key pair in protected form");
+#endif
+
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session,
+					   PTA_HSM_CMD_LOAD_ECC_KEY_PROT,
+					   &op, &ret_orig)))
+			goto out;
+
+		pubkey_x = (uint8_t *)op.params[3].tmpref.buffer;
+		pubkey_y = (uint8_t *)op.params[3].tmpref.buffer +
+			   ECC_KEY_P256_SIZE;
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- Public key coordinates of the loaded key pair:");
+		Do_ADBG_Log("  - Public key X:");
+		Do_ADBG_HexLog(pubkey_x, ECC_KEY_P256_SIZE, 16);
+		Do_ADBG_Log("  - Public key Y:");
+		Do_ADBG_HexLog(pubkey_y, ECC_KEY_P256_SIZE, 16);
+#endif
+
+		/*
+		 * ECDSA signature generation using the temporary enrollment
+		 * key previously loaded
+		 */
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			xtest_tee_ecdsa_test(c, TEE_ECC_CURVE_NIST_P256,
+					     pubkey_x, pubkey_y)))
+			goto out;
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- ECDSA signing generation OK");
+#endif
+	}
+	Do_ADBG_EndSubCase(c, NULL);
+
+#ifdef HSM_SCALAR_TEST
+	/*
+	 * PTA Cmd: ECC Scalar Multiplication and Addition use case
+	 *
+	 * For test purpose, execute the following sequence:
+	 * -> ECC Scalar Multiplication and Addition
+	 *    - if not alread loaded in eHSM, load enrollment seed key used as
+	 *      reference to generate the temporary enrollment private key
+	 *    - calculate temporary enrollment key from this enrollment seed
+	 *
+	 * -> Export of ECC key pair in protected form
+	 *    - export the generated temporary enrollment key and store it in
+	 *      host memory area in protected form
+	 *
+	 * -> Load of ECC key pair in protected form
+	 *    - load into eHSM the temporary enrollment key previously stored by
+	 *      host application in protected form
+	 *    - check the M4 & M5 messages returned are similar to the exported
+	 *      ones
+	 *
+	 * -> ECDSA signature generation with loaded temporary enrollment key
+	 *    - Open 2nd session to call ECDSA cryptographic service
+	 *    - ECC key to be used for the ECDSA signature generation has been
+	 *      loaded in protected form just before. So use public key x & y
+	 *      exported accordingly in the crypto ECDSA request.
+	 */
+	Do_ADBG_BeginSubCase(c, "ECC Scalar Multiplication and Addition");
+	{
+		TEEC_Operation op = TEEC_OPERATION_INITIALIZER;
+		uint8_t m1[ECC_KEY_M1_SIZE] = { 0 };
+		uint8_t m2[ECC_KEY_M2_SIZE] = { 0 };
+		uint8_t m3[ECC_KEY_M3_SIZE] = { 0 };
+		uint8_t m45[ECC_KEY_M4_SIZE + ECC_KEY_M5_SIZE] = { 0 };
+		uint8_t keypair[(3 * ECC_KEY_P256_SIZE) + sizeof(uint32_t)] = { 0 };
+		uint8_t keypub[2 * ECC_KEY_P256_SIZE] = { 0 };
+		uint8_t *keypub_x = NULL;
+		uint8_t *keypub_y = NULL;
+		uint32_t curve = TEE_ECC_CURVE_NIST_P256;
+		uint32_t calc_key_id = 0;
+
+		/*
+		 * ECC Scalar Multiplication and Addition
+		 */
+		op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_VALUE_OUTPUT);
+
+		/* Initialize Inputs parameters */
+		/* Concatenate curve, public key_x, public key_y and private key_d
+		 * in keypair buffer in the respective order
+		 * If Public key x & y are not used, they must be set to 0*/
+		memcpy(keypair + sizeof(uint32_t), pub_key_x_p256,
+		       ECC_KEY_P256_SIZE);
+		memcpy(keypair + sizeof(uint32_t) + ECC_KEY_P256_SIZE,
+		       pub_key_y_p256, ECC_KEY_P256_SIZE);
+		memcpy(keypair + sizeof(uint32_t) + (2 * ECC_KEY_P256_SIZE),
+		       priv_key_d_p256, ECC_KEY_P256_SIZE);
+		op.params[0].tmpref.buffer = (void *)keypair;
+		op.params[0].tmpref.size = (3 * ECC_KEY_P256_SIZE) +
+					   sizeof(uint32_t);
+		/* Curve id set at the beginning of the buffer */
+		*((uint32_t *)op.params[0].tmpref.buffer) = curve;
+
+		op.params[1].tmpref.buffer = (void *)scalar_multiplier_p256;
+		op.params[1].tmpref.size = sizeof(scalar_multiplier_p256);
+		op.params[2].tmpref.buffer = (void *)scalar_addend_p256;
+		op.params[2].tmpref.size = sizeof(scalar_addend_p256);
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- ECC Scalar Multiplication and Addition");
+		Do_ADBG_Log("  with the following parameters:");
+		Do_ADBG_Log("  - Keypair:");
+		Do_ADBG_HexLog(op.params[0].tmpref.buffer,
+			       op.params[0].tmpref.size, 16);
+		Do_ADBG_Log("  - scalar_multiplier_p256:");
+		Do_ADBG_HexLog(op.params[1].tmpref.buffer,
+			       op.params[1].tmpref.size, 16);
+		Do_ADBG_Log("  - scalar_addend_p256:");
+		Do_ADBG_HexLog(op.params[2].tmpref.buffer,
+			       op.params[2].tmpref.size, 16);
+#endif
+
+		/* Initialize Outputs parameters */
+		/* op.params[3].value.a & b already initialize */
+
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session,
+					   PTA_HSM_CMD_ECC_SCALAR_MUL_ADD,
+					   &op, &ret_orig)))
+			goto out;
+
+		/* Get the Key index of the calculated key */
+		calc_key_id = op.params[3].value.a;
+
+		/*
+		 * Export of ECC key pair previously calculated in protected form
+		 */
+		memset((void *)&op, 0, sizeof(TEEC_Operation));
+		op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INOUT,
+						 TEEC_MEMREF_TEMP_INOUT,
+						 TEEC_MEMREF_TEMP_OUTPUT,
+						 TEEC_MEMREF_TEMP_OUTPUT);
+
+		/* Initialize Inputs parameters */
+		/* 1st location of the m1 buffer is set to index of the key to
+		 * export */
+		op.params[0].tmpref.buffer = (void *)m1;
+		op.params[0].tmpref.size = ECC_KEY_M1_SIZE;
+		*((uint32_t *)op.params[0].tmpref.buffer) = calc_key_id;
+
+		/* 1st location of the m2 buffer is set to size of the memory
+		 * allocated for the M2 message */
+		op.params[1].tmpref.buffer = (void *)m2;
+		op.params[1].tmpref.size = ECC_KEY_M2_SIZE;
+		*((uint32_t *)op.params[1].tmpref.buffer) = ECC_KEY_M2_SIZE;
+
+		/* Initialize Outputs parameters */
+		op.params[2].tmpref.buffer = (void *)m3;
+		op.params[2].tmpref.size = ECC_KEY_M3_SIZE;
+		op.params[3].tmpref.buffer = (void *)m45;
+		op.params[3].tmpref.size = ECC_KEY_M4_SIZE + ECC_KEY_M5_SIZE;
+
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session,
+					   PTA_HSM_CMD_EXP_ECC_KEY_PROT,
+					   &op, &ret_orig)))
+			goto out;
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- Export of ECC key pair in protected form");
+		Do_ADBG_Log("  - M1:");
+		Do_ADBG_HexLog(op.params[0].tmpref.buffer,
+			       op.params[0].tmpref.size, 16);
+		Do_ADBG_Log("  - M2:");
+		Do_ADBG_HexLog(op.params[1].tmpref.buffer,
+			       op.params[1].tmpref.size, 16);
+		Do_ADBG_Log("  - M3:");
+		Do_ADBG_HexLog(op.params[2].tmpref.buffer,
+			       op.params[2].tmpref.size, 16);
+		Do_ADBG_Log("  - M45:");
+		Do_ADBG_HexLog(op.params[3].tmpref.buffer,
+			       op.params[3].tmpref.size, 16);
+#endif
+
+		/*
+		 * Load of ECC key pair previously stored in protected form
+		 */
+		memset((void *)&op, 0, sizeof(TEEC_Operation));
+		op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INPUT,
+						 TEEC_MEMREF_TEMP_INOUT);
+
+		/* Initialize Inputs parameters */
+		op.params[0].tmpref.buffer = (void *)m1;
+		op.params[0].tmpref.size = ECC_KEY_M1_SIZE;
+		op.params[1].tmpref.buffer = (void *)m2;
+		op.params[1].tmpref.size = ECC_KEY_M2_SIZE;
+		op.params[2].tmpref.buffer = (void *)m3;
+		op.params[2].tmpref.size = ECC_KEY_M3_SIZE;
+
+		/* Initialize Outputs parameters */
+		/* Output buffer is allocated to return the public key x and y
+		 * related to the loaded key pair.
+		 * In input, this output buffer is filled with the M4 and M5
+		 * messages which will be used for the loading attestation
+		 * checking */
+		memcpy(keypub, m45, ECC_KEY_M4_SIZE + ECC_KEY_M5_SIZE);
+		op.params[3].tmpref.buffer = (void *)keypub;
+		op.params[3].tmpref.size = 2 * ECC_KEY_P256_SIZE;
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- Load of exported ECC key pair in protected form");
+#endif
+
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			TEEC_InvokeCommand(&session,
+					   PTA_HSM_CMD_LOAD_ECC_KEY_PROT,
+					   &op, &ret_orig)))
+			goto out;
+
+		keypub_x = (uint8_t *)op.params[3].tmpref.buffer;
+		keypub_y = (uint8_t *)op.params[3].tmpref.buffer +
+			   ECC_KEY_P256_SIZE;
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- Public key coordinates of the loaded key pair:");
+		Do_ADBG_Log("  - Public key X:");
+		Do_ADBG_HexLog(keypub_x, ECC_KEY_P256_SIZE, 16);
+		Do_ADBG_Log("  - Public key Y:");
+		Do_ADBG_HexLog(keypub_y, ECC_KEY_P256_SIZE, 16);
+#endif
+
+		/*
+		 * ECDSA signature generation using the temporary enrollment
+		 * key previously loaded
+		 */
+		if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+			xtest_tee_ecdsa_test(c, curve, keypub_x, keypub_y)))
+			goto out;
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("- ECDSA signing generation OK");
+#endif
 	}
 	Do_ADBG_EndSubCase(c, NULL);
+#endif /* HSM_SCALAR_TEST */
 
 out:
 	TEEC_CloseSession(&session);
 }
-#endif
+#endif /* CFG_CRYPTO_WITH_HSM */
 
diff --git a/host/xtest/regression_4000.c b/host/xtest/regression_4000.c
index b6c2660..f68b153 100644
--- a/host/xtest/regression_4000.c
+++ b/host/xtest/regression_4000.c
@@ -47,6 +47,8 @@ static void xtest_tee_test_4010(ADBG_Case_t *Case_p);
 static void xtest_tee_test_4011(ADBG_Case_t *Case_p);
 #if !defined(CFG_CRYPTO_ECC_FROM_CRYPTOLIB)
 static void xtest_tee_test_4012(ADBG_Case_t *Case_p);
+TEEC_Result xtest_tee_ecdsa_test(ADBG_Case_t *c, uint32_t curve, void *key_x,
+				 void *key_y);
 #endif
 
 ADBG_CASE_DEFINE(regression, 4001, xtest_tee_test_4001,
@@ -5418,7 +5420,6 @@ static const struct xtest_ac_case xtest_genkey_ac_cases[] = {
 			    nist_186_3_ecdsa_testvector_230),
 };
 
-
 static void xtest_tee_test_4012(ADBG_Case_t *c)
 {
 	TEEC_Session session = { 0 };
@@ -5515,14 +5516,15 @@ static void xtest_tee_test_4012(ADBG_Case_t *c)
 					    TEE_ATTR_ECC_CURVE, curve, 0);
 
 			if (!ADBG_EXPECT_TEEC_SUCCESS(c,
-				ta_crypt_cmd_allocate_transient_object(c, &session,
-						TEE_TYPE_ECDSA_KEYPAIR, max_key_size,
-						&priv_key_handle)))
+				ta_crypt_cmd_allocate_transient_object(c,
+					&session, TEE_TYPE_ECDSA_KEYPAIR,
+					max_key_size, &priv_key_handle)))
 				goto out;
 
 			if (!ADBG_EXPECT_TEEC_SUCCESS(c,
-				ta_crypt_cmd_generate_key(c, &session, priv_key_handle,
-						max_key_size, key_attrs, num_key_attrs)))
+				ta_crypt_cmd_generate_key(c, &session,
+					priv_key_handle, max_key_size,
+					key_attrs, num_key_attrs)))
 				goto out;
 			break;
 
@@ -5555,8 +5557,7 @@ static void xtest_tee_test_4012(ADBG_Case_t *c)
 				goto out;
 
 			if (!ADBG_EXPECT_TEEC_SUCCESS(c,
-						ta_crypt_cmd_free_operation(c, &session,
-							op)))
+				ta_crypt_cmd_free_operation(c, &session, op)))
 				goto out;
 			/*
 			 * The salt or K is random so we can't verify
@@ -5565,28 +5566,27 @@ static void xtest_tee_test_4012(ADBG_Case_t *c)
 			 * output is correct.
 			 */
 			if (!ADBG_EXPECT_TEEC_SUCCESS(c,
-				ta_crypt_cmd_allocate_operation(c,
-							&session, &op, tv->algo,
-							TEE_MODE_VERIFY, max_key_size)))
+				ta_crypt_cmd_allocate_operation(c, &session,
+					&op, tv->algo, TEE_MODE_VERIFY,
+					max_key_size)))
 				goto out;
 
 			if (!ADBG_EXPECT_TEEC_SUCCESS(c,
-				ta_crypt_cmd_set_operation_key(c,
-							&session, op, priv_key_handle)))
+				ta_crypt_cmd_set_operation_key(c, &session, op,
+					priv_key_handle)))
 				goto out;
 
 			if (!ADBG_EXPECT_TEEC_SUCCESS(c,
-				ta_crypt_cmd_free_transient_object(c,
-							&session, priv_key_handle)))
+				ta_crypt_cmd_free_transient_object(c, &session,
+					priv_key_handle)))
 				goto out;
 
 			priv_key_handle = TEE_HANDLE_NULL;
 
 			if (!ADBG_EXPECT_TEEC_SUCCESS(c,
-						ta_crypt_cmd_asymmetric_verify(c,
-							&session, op, algo_params,
-							num_algo_params, ptx_hash,
-							ptx_hash_size, out, out_size)))
+				ta_crypt_cmd_asymmetric_verify(c, &session, op,
+					algo_params, num_algo_params, ptx_hash,
+					ptx_hash_size, out, out_size)))
 				goto out;
 			break;
 
@@ -5613,4 +5613,149 @@ static void xtest_tee_test_4012(ADBG_Case_t *c)
 out:
 	TEEC_CloseSession(&session);
 }
+
+/*
+ * ECDSA P256 payload and empty key descriptors
+ */
+static const uint8_t ecdsa_ptx[] = {
+	0x05, 0xa0, 0x5b, 0xb2, 0x88, 0x29, 0xcf, 0x6f, 0x43, 0x5c, 0x42, 0x2c,
+	0x09, 0x57, 0xb1, 0x03, 0x59, 0x27, 0x42, 0x93, 0x27, 0x80, 0x26, 0x53,
+	0xdf, 0xb1, 0xc3, 0x25, 0xa8, 0xd8, 0x13, 0x2f, 0xe6, 0x52, 0x47, 0xe6,
+	0x02, 0x76, 0xb1, 0x6b, 0x6d, 0x83, 0xe0, 0x1b, 0xe2, 0xd6, 0x0d, 0x62,
+	0xec, 0x61, 0xb6, 0xcf, 0xa9, 0x58, 0x88, 0x6e, 0xcd, 0x2d, 0x82, 0x52,
+	0xe9, 0xbf, 0x58, 0x71, 0xee, 0xcf, 0x15, 0xb5, 0xed, 0xb3, 0x05, 0x4f,
+	0x20, 0x4e, 0xd2, 0x4f, 0x2e, 0x3f, 0xed, 0x71, 0xab, 0x59, 0x2f, 0x3a,
+	0xde, 0x53, 0xc1, 0x44, 0xc8, 0xc1, 0x39, 0xd7, 0x61, 0x43, 0x05, 0xb8,
+	0x25, 0xfd, 0x0d, 0x46, 0xcf, 0x47, 0x94, 0xc2, 0x65, 0xa5, 0x5f, 0xef,
+	0x74, 0xf9, 0x1a, 0xdb, 0x9d, 0xf7, 0xf7, 0xfc, 0x50, 0xda, 0x98, 0x7e,
+	0xd8, 0x55, 0x2f, 0xdc, 0x98, 0xcd, 0xe4, 0xae
+};
+static const uint8_t ecdsa_empty_key[] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+//#define HSM_TEST_DEBUG
+
+/*
+ * ECDSA signature generation with pre-loaded key
+ */
+TEEC_Result xtest_tee_ecdsa_test(ADBG_Case_t *c, uint32_t curve, void *key_x,
+				 void *key_y)
+{
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	TEEC_Session session = { 0 };
+	TEE_OperationHandle op = TEE_HANDLE_NULL;
+	TEE_ObjectHandle pub_key_hdl = TEE_HANDLE_NULL;
+	TEE_ObjectHandle priv_key_hdl = TEE_HANDLE_NULL;
+	TEE_Attribute key_attrs[8];
+	TEE_Attribute algo_params[1];
+	size_t num_algo_params = 0;
+	size_t num_key_attrs = 0;
+	uint8_t out[256];
+	size_t out_size;
+	uint8_t ptx_hash[TEE_MAX_HASH_SIZE];
+	size_t ptx_hash_size;
+	size_t ecdsa_ptx_size;
+	size_t max_key_size;
+	uint32_t ret_orig;
+
+	if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+		xtest_teec_open_session(&session,
+					&crypt_user_ta_uuid,
+					NULL, &ret_orig)))
+		goto out;
+
+	/* ECDSA Signing is done on the hash of the payload */
+	if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+		ta_crypt_cmd_allocate_operation(c, &session,
+						&op, TEE_ALG_SHA256,
+						TEE_MODE_DIGEST, 0)))
+		goto out;
+
+	ptx_hash_size = sizeof(ptx_hash);
+	ecdsa_ptx_size = sizeof(ecdsa_ptx);
+	if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+		ta_crypt_cmd_digest_do_final(c, & session, op,
+					     ecdsa_ptx, ecdsa_ptx_size,
+					     ptx_hash, &ptx_hash_size)))
+		goto out;
+
+	if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+		ta_crypt_cmd_free_operation(c, &session, op)))
+		goto out;
+
+	/* Load ECC key pair descriptors */
+	max_key_size = sizeof(ecdsa_empty_key) * 8;
+
+	xtest_add_attr_value(&num_key_attrs, key_attrs,
+			     TEE_ATTR_ECC_CURVE, curve, 0);
+
+	xtest_add_attr(&num_key_attrs, key_attrs,
+		       TEE_ATTR_ECC_PUBLIC_VALUE_X,
+		       key_x, sizeof(ecdsa_empty_key));
+	xtest_add_attr(&num_key_attrs, key_attrs,
+		       TEE_ATTR_ECC_PUBLIC_VALUE_Y,
+		       key_y, sizeof(ecdsa_empty_key));
+
+	if (!ADBG_EXPECT_TRUE(c,
+		create_key(c, &session, max_key_size,
+			   TEE_TYPE_ECDSA_PUBLIC_KEY, key_attrs,
+			   num_key_attrs, &pub_key_hdl)))
+		goto out;
+
+	xtest_add_attr(&num_key_attrs, key_attrs,
+			TEE_ATTR_ECC_PRIVATE_VALUE,
+			ecdsa_empty_key, sizeof(ecdsa_empty_key));
+
+	if (!ADBG_EXPECT_TRUE(c,
+		create_key(c, &session, max_key_size,
+			   TEE_TYPE_ECDSA_KEYPAIR, key_attrs,
+			   num_key_attrs, &priv_key_hdl)))
+		goto out;
+
+	/* ECDSA Signature genration operation */
+	out_size = sizeof(out);
+	memset(out, 0, sizeof(out));
+
+	if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+		ta_crypt_cmd_allocate_operation(c, &session, &op,
+						TEE_ALG_ECDSA_P256,
+						TEE_MODE_SIGN, max_key_size)))
+		goto out;
+
+	if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+		ta_crypt_cmd_set_operation_key(c, &session, op,
+					       priv_key_hdl)))
+		goto out;
+
+	if (!ADBG_EXPECT_TEEC_SUCCESS(c,
+		ta_crypt_cmd_asymmetric_sign(c, &session, op,
+					     algo_params, num_algo_params,
+					     ptx_hash, ptx_hash_size, out,
+					     &out_size)))
+		goto out;
+
+#ifdef HSM_TEST_DEBUG
+		Do_ADBG_Log("Signature generation:");
+		Do_ADBG_HexLog(out, out_size, 16);
+#endif
+
+	res = TEEC_SUCCESS;
+out:
+	ADBG_EXPECT_TEEC_SUCCESS(c,
+		ta_crypt_cmd_free_operation(c, &session, op));
+
+	ADBG_EXPECT_TEEC_SUCCESS(c,
+		ta_crypt_cmd_free_transient_object(c, &session, pub_key_hdl));
+
+	ADBG_EXPECT_TEEC_SUCCESS(c,
+		ta_crypt_cmd_free_transient_object(c, &session, priv_key_hdl));
+
+	TEEC_CloseSession(&session);
+
+	return res;
+}
+
 #endif /* !CFG_CRYPTO_ECC_FROM_CRYPTOLIB */
-- 
2.7.4

